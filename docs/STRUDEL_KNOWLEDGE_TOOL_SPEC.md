# Strudel Knowledge Tool Spec (Single Consolidated Tool)

## Goal
Implement one authoritative tool for the agent:

`strudel_knowledge(query)`

This tool must unify what users currently get from the Strudel REPL side tabs:
- `sounds` tab
- `reference` tab

The response must be concise and practical: canonical usage plus minimal examples.

## Source of Truth (Must Match Current Strudel Code)

### 1) Reference data
Use the same reference dataset as the REPL reference tab:
- `strudel/doc.json`
- REPL implementation: `strudel/website/src/repl/components/panel/Reference.jsx`

Current UI behavior to mirror:
- list/search by function name and synonyms
- include description, params, examples, tags
- filter out invalid/internal entries (e.g. names starting with `_`)

Implementation note:
- `doc.json` tags can contain objects (`{ title, value, ... }`), while UI currently keeps only string tags.
- For robust tool results, normalize tags from both forms:
  - string tag -> keep as-is
  - object tag -> use `value` or `text`

### 2) Sounds data
Use the same runtime sound registry as the REPL sounds tab:
- sound registry: `soundMap` from `@strudel/webaudio` / `superdough`
- REPL implementation: `strudel/website/src/repl/components/panel/SoundsTab.jsx`
- sound registration APIs: `registerSound(...)`, `samples(...)`, `registerSynthSounds()`, `registerZZFXSounds()`
- prebaked library loading: `strudel/website/src/repl/prebake.mjs`

Sound metadata fields used by UI filtering:
- `data.type` (e.g. `sample`, `synth`, `soundfont`, `wavetable`)
- `data.tag` (e.g. `drum-machines`)
- `data.prebake` (true for bundled/preloaded sounds)

Mirror REPL category semantics:
- `user`: sounds with `!data.prebake`
- `drums`: `data.type === 'sample' && data.tag === 'drum-machines'`
- `samples`: `data.type === 'sample' && data.tag !== 'drum-machines'`
- `synths`: `data.type in ['synth', 'soundfont']`
- `wavetables`: `data.type === 'wavetable'`
- `all`: everything except internal keys starting with `_`

## Tool Contract

## Function
`strudel_knowledge(query)`

## Input
`query` is a free-form string generated by the LLM.

No strict query syntax should be required. The tool must interpret natural language intent.

### Free-form query examples
- `"what does fast do"`
- `"how to make reverb in strudel"`
- `"is trancegate valid in strudel"`
- `"list drum-machine sounds like bd sd hh"`
- `"what are the params for room and give an example"`

### Optional extended object form (backward-compatible)
```json
{
  "q": "what does room do",
  "domain": "auto|reference|sounds",
  "mode": "auto|search|detail|list",
  "limit": 5
}
```

## Output (structured)
```json
{
  "ok": true,
  "query": "room",
  "domain": "reference",
  "mode": "detail",
  "answer": "Short authoritative answer for agent/user",
  "items": [
    {
      "kind": "function",
      "name": "room",
      "synonyms": [],
      "usage": "s(\"bd\").room(0.5)",
      "params": [
        { "name": "...", "type": "...", "description": "..." }
      ],
      "examples": ["...", "..."],
      "tags": ["effects"]
    }
  ],
  "sources": [
    "doc.json",
    "soundMap"
  ],
  "notes": []
}
```

Failure shape:
```json
{
  "ok": false,
  "query": "trancegate",
  "reason": "not_found",
  "answer": "No authoritative match in bundled Strudel reference/sounds.",
  "suggestions": ["trance", "gate", "shape"],
  "sources": ["doc.json", "soundMap"]
}
```

## Response Rules
- Be authoritative, not speculative.
- Never invent function names, params, sounds, banks, or aliases.
- Prefer exact symbol matches first, then synonyms, then fuzzy matches.
- Fuzzy search is mandatory for both `reference` and `sounds` lookups.
- Keep examples minimal:
  - max 2 examples for function detail
  - max 1 example for list/search result items
- If multiple matches exist, return short ranked list (default top 5).
- If query is ambiguous, return grouped results by domain (`reference`, `sounds`).

### Reference Result Requirement (Mandatory)
For every returned reference API item, include:
- `description` (from `doc.json`)
- `examples` (at least 1 when present in source)

If an API has no example in source docs, return `examples: []` and add a note indicating no example exists in the bundled snapshot.

## Retrieval + Ranking
1. Parse query intent (`reference`, `sounds`, `auto`).
2. Try exact matches:
   - function name
   - synonym
   - sound name
3. Fallback fuzzy ranking over normalized tokens (required behavior, not optional).
4. Prefer higher confidence in this order:
   - exact function/sound name
   - exact synonym
   - prefix match
   - fuzzy text match

## Build/Runtime Indexing

### Reference index
Build a normalized index at startup (or build time) from `doc.json`:
- `name`
- `synonyms`
- `description` (plain text)
- `params`
- `examples`
- normalized `tags`

### Sounds index
Build from current `soundMap.get()` at call time (or cache + invalidate on soundMap update):
- `name`
- `type`, `tag`, `prebake`
- sample count metadata (if available):
  - sample: from `data.samples`
  - wavetable: from `data.tables`
  - soundfont: from `data.fonts`

## Minimum Supported Intents
- Unknown symbol resolution (`"is X valid?"`, `"symbol:X"`)
- Function detail (`"what does fast do"`)
- Function search/list (`"show euclid-related functions"`)
- Sounds/bank lookup (`"sounds drum-machines"`, `"is bd available"`)
- Category listings (`"list synths"`, `"list user sounds"`)

## Agent Usage Policy
Use `strudel_knowledge(query)` only when:
- symbol/param/sound uncertainty exists
- apply validation reports unknown symbol
- user explicitly asks docs/reference/sounds questions

Then revise code and retry apply once.

## Acceptance Criteria
1. Querying a known function (e.g. `room`) returns canonical function detail with params and <=2 examples.
2. Querying a known sound/bank returns category-aware results from `soundMap`.
3. Querying unknown symbol returns `ok:false` with non-hallucinated suggestions.
4. Tool output is stable offline (no network dependency required for lookup itself).
5. Results align with what user can see in Strudel `reference`/`sounds` tabs.

## Suggested Implementation Order
1. Create `buildReferenceIndex(docJson)`
2. Create `buildSoundsIndex(soundMapSnapshot)`
3. Create `parseKnowledgeQuery(query)`
4. Create `searchReference(...)` and `searchSounds(...)`
5. Create `formatKnowledgeResponse(...)`
6. Add tests for exact, fuzzy, ambiguous, and not_found cases

## Test Cases (Starter)
- `strudel_knowledge("symbol:room")`
- `strudel_knowledge("what is euclid")`
- `strudel_knowledge("sounds:drum-machines")`
- `strudel_knowledge("list wavetables")`
- `strudel_knowledge("is trancegate valid")`
- `strudel_knowledge("i forgot exact name maybe rooom or roomsize? show api with examples")`
